EIAH Arquitetura 31/10/2025 (EIAH_Builder Agentic)
===================================================

Contexto e principios
- Monorepo PNPM segue organizado em `apps/*`, `packages/*` e `infra/*`, com lint/build/test padronizados via `pnpm` scripts e pipelines GitHub Actions.
- Plataforma multi-tenant consolidada: particoes por `Tenant`/`Workspace`/`User`/`ApiToken` em `apps/api/prisma/schema.prisma`, com soft deletes e trilhas de auditoria (`createdBy`/`updatedBy`).
- Missao continua centrada em runs auditaveis, billing automatico e painel self-service; agora com suporte a agentes especializados orquestrados de ponta a ponta.

Componentizacao 2025
- **Core agentic** - `packages/core/orchestrator/*` integra ciclo perceive/plan/act/reflect, motor de planos (`planManager`) e registradores de step. Eventos sao persistidos via adapters (`RunEventStore`, `TelemetryBridge`) e expostos a API em tempo real.
- **Acoes e ferramentas** - `packages/core/actions` encapsula ferramentas versionadas, contratos de entrada/saida e guardrails (`requireIdempotency`, `rateLimiter`). Workers consomem essas acoes de forma declarativa.
- **Memoria** - `packages/core/memory` agrega `RedisMemoryStore` (curto prazo), `PgConversationLog` (historico) e conector opcional para vetor store (`packages/core/memory/vector` suportando pgvector/Weaviate). Jobs `memorySync` e `memoryRetention` mantem consistencia.
- **Contratos compartilhados** - `packages/core/types` exporta tipos zod/TypeScript (`Run`, `RunEvent`, `AgentProfile`, `BillingLedgerEntry`) reusados por API, web, CLI e workers.
- **API** - `apps/api` virou gateway modular (Express + tRPC). Rotas em `apps/api/src/modules/*` organizam runs, billing, agents, defi, memory e admin. Middleware `enforceTenant` injeta `authContext`, enquanto `requireRole` aplica RBAC por operacao.
- **Workers** - `apps/workers` hospeda consumidores BullMQ e pipelines Temporal para execucoes assincronas (DeFi, juridico, ingestao de memoria). Cada worker registra health/status via TelemetryBridge.
- **Frontend** - `apps/web` migrou para Remix + Tailwind + TanStack Query. Paginas em `apps/web/app/routes/app/*.tsx` combinam dashboards de runs, agents, billing, quotas e incidentes. `sessionStore` sincroniza tokens, roles e preferencias do workspace.
- **CLI & automacao** - `apps/cli` entrega comandos `eiah tokens`, `eiah tenants`, `eiah runs replay`, `eiah billing reconcile`. Scripts de seed/rotina ficam em `apps/api/scripts/*` e suportam ambientes locais e staging.

Fluxo principal de execucao de run
1. Cliente envia `POST /api/runs` ou usa `eiah runs trigger`. `enforceTenant` + `requireRole` validam escopo/role, `runSchema` (Zod) garante payload e o `RunIngestor` registra requisicao inicial (`RunEvent` status `queued`).
2. `RunDispatcher` publica mensagem na fila BullMQ (`agent-runs`). Orchestrator recebe o job, recupera contexto (memoria curta, historico, estado do agente) e instancia o plano inicial.
3. Cada step do Orchestrator (perceive/plan/act/reflect) emite eventos persistidos via `RunEventStore`. Acoes externas (DeFi, compliance, analise documental) sao delegadas a workers especializados com idempotencia e dedupe.
4. `BillingEngine` estima custo incremental por token/tool, aplica rebates conforme plano (`PlanQuota`, `Pricing`, `VolumeDiscount`) e grava entradas em `BillingLedger`.
5. Ao concluir (ou falhar), o Orchestrator grava `RunEvent` final com `traceId`, metricas, custos consolidados e metadados exportaveis. Web e CLI consomem atualizacoes em tempo real via Server-Sent Events (`/api/runs/:id/stream`) e queries cacheadas.

Memoria e conhecimento
- `ContextSnapshotService` compoe memoria curta (Redis), historico relevante (Postgres) e embeddings recentes (vetor store) respeitando janelas configuraveis por agente.
- Jobs diarios consolidam eventos em `KnowledgeBase` (Postgres + S3) para auditoria e treinamento supervisionado.
- Ferramentas possuem `MemoryPolicy` declarativa (ex.: persistir outputs relevantes, limpar dados sensiveis) cumprindo GDPR/Lei Geral de Protecao de Dados.

Observabilidade e FinOps
- Logging estruturado com Pino, entregue a Loki/Elastic via Fluent Bit. Todo evento carrega `traceId`, `runId`, `tenantId`, `workspaceId` e `costCents`.
- Metricas OpenTelemetry exportadas para Tempo/Prometheus: latencia por agente, throughput de filas, sucesso/erro por ferramenta, backlog e uso de memoria.
- Tracing distribuido cobre API, Orchestrator e workers, com integracao ao Grafana Tempo e correlacao com logs/billing.
- Paines `apps/web/app/routes/app/metrics` expoem KPI: tempo medio por run, custo medio por agente, consumo de quota, taxa de erro. Alertas automaticos disparam via Opsgenie/Slack quando limites sao atingidos.
- `BillingReconciler` concilia ledger interno com gateway (Stripe/Adyen) e gera relatorios de auditoria mensal exportaveis (`/api/billing/reports`).

Seguranca e governanca
- Tokens (`ApiToken`, `ServiceToken`) possuem expiracao rotativa, escopos granulares e podem ser associados a politicas de IP/rate-limit. Rotacao automatica integra Secret Manager.
- RBAC multi-nivel: `RoleAssignment` em `Tenant`, `Workspace`, `AgentProfile`. Painel admin (`apps/web/app/routes/app/admin`) gerencia roles, tokens, quotas e acessos.
- Dados sensiveis em `RunEvent.metadata` sao mascarados (PCI/PII) antes de persistir/logar. Campos criticos criptografados com KMS.
- `requireIdempotency` backed por Redis + Postgres garante dedupe de requests criticos. Playbooks de auditoria exportam trilhas com assinaturas digitais.

Resiliencia e confiabilidade
- Health-check enriquecido (`/api/health`) cobre Postgres, Redis, fila, OpenAI, gateway de pagamento e workers. Status exposto para Kubernetes HPA.
- Modo `degraded` ativa fallback de agentes (modelo menor) e limites de custo quando dependencias apresentam instabilidade.
- Estrategias de retry/backoff centralizadas (`packages/core/retry`). Falhas criticas disparam incident auto-created no Jira/PagerDuty.

Ferramentas de engenharia
- Pipelines CI/CD verificam lint/test/build, migrations (`prisma migrate diff`), geracao de tipos e testes e2e com Playwright/Temporal test harness.
- `apps/cli` auxilia devs com `eiah dev up` (docker-compose), `eiah db snapshot`, `eiah memory prune`. Terraform em `infra/terraform` e Helm charts em `infra/helm`.

Roadmap 2026+
- Multi-model Orchestrator com escolhas dinamicas por agente (OpenAI, Anthropic, modelos internos).
- Marketplace de agentes com versionamento, contratos de conformidade e billing granular por ferramenta.
- Replay e edicao visual de runs no frontend com suporte a branching e rollback.
- Aprendizado ativo: etiquetagem semi-automatica e feedback humano para melhorar agentes especializados.
